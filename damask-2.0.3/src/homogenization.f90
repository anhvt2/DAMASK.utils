! Copyright 2011-19 Max-Planck-Institut f端r Eisenforschung GmbH
! 
! DAMASK is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
! 
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
! GNU General Public License for more details.
! 
! You should have received a copy of the GNU General Public License
! along with this program. If not, see <http://www.gnu.org/licenses/>.
!--------------------------------------------------------------------------------------------------
!> @author Franz Roters, Max-Planck-Institut f端r Eisenforschung GmbH
!> @author Philip Eisenlohr, Max-Planck-Institut f端r Eisenforschung GmbH
!> @author Denny Tjahjanto, Max-Planck-Institut f端r Eisenforschung GmbH
!> @brief homogenization manager, organizing deformation partitioning and stress homogenization
!--------------------------------------------------------------------------------------------------
module homogenization
 use prec, only: &
   pInt, &
   pReal

!--------------------------------------------------------------------------------------------------
! General variables for the homogenization at a  material point
 implicit none
 private
   real(pReal),   dimension(:,:,:,:),   allocatable, public :: &
   materialpoint_F0, &                                                                              !< def grad of IP at start of FE increment
   materialpoint_F, &                                                                               !< def grad of IP to be reached at end of FE increment
   materialpoint_P                                                                                  !< first P--K stress of IP
 real(pReal),   dimension(:,:,:,:,:,:), allocatable, public ::  &
   materialpoint_dPdF                                                                               !< tangent of first P--K stress at IP
 real(pReal),   dimension(:,:,:),       allocatable, public :: &
   materialpoint_results                                                                            !< results array of material point
 integer(pInt),                                      public, protected  :: &
   materialpoint_sizeResults, &
   homogenization_maxSizePostResults, &
   thermal_maxSizePostResults, &
   damage_maxSizePostResults

 real(pReal),   dimension(:,:,:,:),     allocatable, private :: &
   materialpoint_subF0, &                                                                           !< def grad of IP at beginning of homogenization increment
   materialpoint_subF                                                                               !< def grad of IP to be reached at end of homog inc
 real(pReal),   dimension(:,:),         allocatable, private :: &
   materialpoint_subFrac, &
   materialpoint_subStep, &
   materialpoint_subdt
 logical,       dimension(:,:),         allocatable, private :: &
   materialpoint_requested, &
   materialpoint_converged
 logical,       dimension(:,:,:),       allocatable, private :: &
   materialpoint_doneAndHappy

 public ::  &
   homogenization_init, &
   materialpoint_stressAndItsTangent, &
   materialpoint_postResults
 private :: &
   partitionDeformation, &
   updateState, &
   averageStressAndItsTangent, &
   postResults

contains


!--------------------------------------------------------------------------------------------------
!> @brief module initialization
!--------------------------------------------------------------------------------------------------
subroutine homogenization_init
 use math, only: &
   math_I3
 use debug, only: &
   debug_level, &
   debug_homogenization, &
   debug_levelBasic, &
   debug_e, &
   debug_g
 use mesh, only: &
   theMesh, &
   mesh_element
 use constitutive, only: &
   constitutive_plasticity_maxSizePostResults, &
   constitutive_source_maxSizePostResults
 use crystallite, only: &
   crystallite_maxSizePostResults
 use config, only: &
  config_deallocate, &
  config_homogenization, &
  homogenization_name
 use material
 use homogenization_none
 use homogenization_isostrain
 use homogenization_RGC
 use thermal_isothermal
 use thermal_adiabatic
 use thermal_conduction
 use damage_none
 use damage_local
 use damage_nonlocal
 use IO
 use numerics, only: &
   worldrank

 implicit none
 integer(pInt), parameter :: FILEUNIT = 200_pInt
 integer(pInt) :: e,i,p
 integer(pInt), dimension(:,:), pointer :: thisSize
 integer(pInt), dimension(:)  , pointer :: thisNoutput
 character(len=64), dimension(:,:), pointer :: thisOutput
 character(len=32) :: outputName                                                                    !< name of output, intermediate fix until HDF5 output is ready
 logical :: valid


 if (any(homogenization_type == HOMOGENIZATION_NONE_ID))      call homogenization_none_init
 if (any(homogenization_type == HOMOGENIZATION_ISOSTRAIN_ID)) call homogenization_isostrain_init
 if (any(homogenization_type == HOMOGENIZATION_RGC_ID))       call homogenization_RGC_init

 if (any(thermal_type == THERMAL_isothermal_ID)) call thermal_isothermal_init
 if (any(thermal_type == THERMAL_adiabatic_ID))  call thermal_adiabatic_init
 if (any(thermal_type == THERMAL_conduction_ID)) call thermal_conduction_init

 if (any(damage_type == DAMAGE_none_ID))      call damage_none_init
 if (any(damage_type == DAMAGE_local_ID))     call damage_local_init
 if (any(damage_type == DAMAGE_nonlocal_ID))  call damage_nonlocal_init

!--------------------------------------------------------------------------------------------------
! write description file for homogenization output
 mainProcess2: if (worldrank == 0) then
   call IO_write_jobFile(FILEUNIT,'outputHomogenization')
   do p = 1,size(config_homogenization)
     if (any(material_homogenizationAt == p)) then
       i = homogenization_typeInstance(p)                                                               ! which instance of this homogenization type
       valid = .true.                                                                                   ! assume valid
       select case(homogenization_type(p))                                                              ! split per homogenization type
         case (HOMOGENIZATION_NONE_ID)
           outputName = HOMOGENIZATION_NONE_label
           thisOutput => null()
           thisSize   => null()
         case (HOMOGENIZATION_ISOSTRAIN_ID)
           outputName = HOMOGENIZATION_ISOSTRAIN_label
           thisOutput => null()
           thisSize   => null()
         case (HOMOGENIZATION_RGC_ID)
           outputName = HOMOGENIZATION_RGC_label
           thisOutput => homogenization_RGC_output
           thisSize   => homogenization_RGC_sizePostResult
         case default
           valid = .false.
       end select
       write(FILEUNIT,'(/,a,/)')  '['//trim(homogenization_name(p))//']'
       if (valid) then
         write(FILEUNIT,'(a)') '(type)'//char(9)//trim(outputName)
         write(FILEUNIT,'(a,i4)') '(ngrains)'//char(9),homogenization_Ngrains(p)
         if (homogenization_type(p) /= HOMOGENIZATION_NONE_ID .and. &
             homogenization_type(p) /= HOMOGENIZATION_ISOSTRAIN_ID) then
           do e = 1,size(thisOutput(:,i))
             write(FILEUNIT,'(a,i4)') trim(thisOutput(e,i))//char(9),thisSize(e,i)
           enddo
         endif
       endif
       i = thermal_typeInstance(p)                                                                      ! which instance of this thermal type
       valid = .true.                                                                                   ! assume valid
       select case(thermal_type(p))                                                                     ! split per thermal type
         case (THERMAL_isothermal_ID)
           outputName = THERMAL_isothermal_label
           thisNoutput => null()
           thisOutput => null()
           thisSize   => null()
         case (THERMAL_adiabatic_ID)
           outputName = THERMAL_adiabatic_label
           thisNoutput => thermal_adiabatic_Noutput
           thisOutput => thermal_adiabatic_output
           thisSize   => thermal_adiabatic_sizePostResult
         case (THERMAL_conduction_ID)
           outputName = THERMAL_conduction_label
           thisNoutput => thermal_conduction_Noutput
           thisOutput => thermal_conduction_output
           thisSize   => thermal_conduction_sizePostResult
         case default
           valid = .false.
       end select
       if (valid) then
         write(FILEUNIT,'(a)') '(thermal)'//char(9)//trim(outputName)
         if (thermal_type(p) /= THERMAL_isothermal_ID) then
           do e = 1,thisNoutput(i)
             write(FILEUNIT,'(a,i4)') trim(thisOutput(e,i))//char(9),thisSize(e,i)
           enddo
         endif
       endif
       i = damage_typeInstance(p)                                                                       ! which instance of this damage type
       valid = .true.                                                                                   ! assume valid
       select case(damage_type(p))                                                                      ! split per damage type
         case (DAMAGE_none_ID)
           outputName = DAMAGE_none_label
           thisNoutput => null()
           thisOutput => null()
           thisSize   => null()
         case (DAMAGE_local_ID)
           outputName = DAMAGE_local_label
           thisNoutput => damage_local_Noutput
           thisOutput => damage_local_output
           thisSize   => damage_local_sizePostResult
         case (DAMAGE_nonlocal_ID)
           outputName = DAMAGE_nonlocal_label
           thisNoutput => damage_nonlocal_Noutput
           thisOutput => damage_nonlocal_output
           thisSize   => damage_nonlocal_sizePostResult
         case default
           valid = .false.
       end select
       if (valid) then
         write(FILEUNIT,'(a)') '(damage)'//char(9)//trim(outputName)
         if (damage_type(p) /= DAMAGE_none_ID) then
           do e = 1,thisNoutput(i)
             write(FILEUNIT,'(a,i4)') trim(thisOutput(e,i))//char(9),thisSize(e,i)
           enddo
         endif
       endif
     endif
   enddo
   close(FILEUNIT)
 endif mainProcess2

 call config_deallocate('material.config/homogenization')

!--------------------------------------------------------------------------------------------------
! allocate and initialize global variables
 allocate(materialpoint_dPdF(3,3,3,3,theMesh%elem%nIPs,theMesh%nElems),       source=0.0_pReal)
 allocate(materialpoint_F0(3,3,theMesh%elem%nIPs,theMesh%nElems),             source=0.0_pReal)
 materialpoint_F0 = spread(spread(math_I3,3,theMesh%elem%nIPs),4,theMesh%nElems)                          ! initialize to identity
 allocate(materialpoint_F(3,3,theMesh%elem%nIPs,theMesh%nElems),              source=0.0_pReal)
 materialpoint_F = materialpoint_F0                                                                 ! initialize to identity
 allocate(materialpoint_subF0(3,3,theMesh%elem%nIPs,theMesh%nElems),          source=0.0_pReal)
 allocate(materialpoint_subF(3,3,theMesh%elem%nIPs,theMesh%nElems),           source=0.0_pReal)
 allocate(materialpoint_P(3,3,theMesh%elem%nIPs,theMesh%nElems),              source=0.0_pReal)
 allocate(materialpoint_subFrac(theMesh%elem%nIPs,theMesh%nElems),            source=0.0_pReal)
 allocate(materialpoint_subStep(theMesh%elem%nIPs,theMesh%nElems),            source=0.0_pReal)
 allocate(materialpoint_subdt(theMesh%elem%nIPs,theMesh%nElems),              source=0.0_pReal)
 allocate(materialpoint_requested(theMesh%elem%nIPs,theMesh%nElems),          source=.false.)
 allocate(materialpoint_converged(theMesh%elem%nIPs,theMesh%nElems),          source=.true.)
 allocate(materialpoint_doneAndHappy(2,theMesh%elem%nIPs,theMesh%nElems),     source=.true.)

!--------------------------------------------------------------------------------------------------
! allocate and initialize global state and postresutls variables
 homogenization_maxSizePostResults = 0_pInt
 thermal_maxSizePostResults        = 0_pInt
 damage_maxSizePostResults         = 0_pInt
 do p = 1,size(config_homogenization)
   homogenization_maxSizePostResults = max(homogenization_maxSizePostResults,homogState       (p)%sizePostResults)
   thermal_maxSizePostResults        = max(thermal_maxSizePostResults,       thermalState     (p)%sizePostResults)
   damage_maxSizePostResults         = max(damage_maxSizePostResults        ,damageState      (p)%sizePostResults)
 enddo

 materialpoint_sizeResults = 1 &                                                                    ! grain count
                           + 1 + homogenization_maxSizePostResults &                                ! homogSize & homogResult
                               + thermal_maxSizePostResults        &
                               + damage_maxSizePostResults         &
                           + homogenization_maxNgrains * (1 + crystallite_maxSizePostResults &      ! crystallite size & crystallite results
                                                        + 1 + constitutive_plasticity_maxSizePostResults &     ! constitutive size & constitutive results
                                                            + constitutive_source_maxSizePostResults)
 allocate(materialpoint_results(materialpoint_sizeResults,theMesh%elem%nIPs,theMesh%nElems))

 write(6,'(/,a)')   ' <<<+-  homogenization init  -+>>>'

 if (iand(debug_level(debug_homogenization), debug_levelBasic) /= 0_pInt) then
#ifdef TODO
   write(6,'(a32,1x,7(i8,1x))')   'homogenization_state0:          ', shape(homogenization_state0)
   write(6,'(a32,1x,7(i8,1x))')   'homogenization_subState0:       ', shape(homogenization_subState0)
   write(6,'(a32,1x,7(i8,1x))')   'homogenization_state:           ', shape(homogenization_state)
#endif
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_dPdF:             ', shape(materialpoint_dPdF)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_F0:               ', shape(materialpoint_F0)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_F:                ', shape(materialpoint_F)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_subF0:            ', shape(materialpoint_subF0)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_subF:             ', shape(materialpoint_subF)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_P:                ', shape(materialpoint_P)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_subFrac:          ', shape(materialpoint_subFrac)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_subStep:          ', shape(materialpoint_subStep)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_subdt:            ', shape(materialpoint_subdt)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_requested:        ', shape(materialpoint_requested)
   write(6,'(a32,1x,7(i8,1x))')   'materialpoint_converged:        ', shape(materialpoint_converged)
   write(6,'(a32,1x,7(i8,1x),/)') 'materialpoint_doneAndHappy:     ', shape(materialpoint_doneAndHappy)
   write(6,'(a32,1x,7(i8,1x))')   'maxSizePostResults: ', homogenization_maxSizePostResults
 endif
 flush(6)

 if (debug_g < 1 .or. debug_g > homogenization_Ngrains(mesh_element(3,debug_e))) &
   call IO_error(602_pInt,ext_msg='constituent', el=debug_e, g=debug_g)

end subroutine homogenization_init


!--------------------------------------------------------------------------------------------------
!> @brief  parallelized calculation of stress and corresponding tangent at material points
!--------------------------------------------------------------------------------------------------
subroutine materialpoint_stressAndItsTangent(updateJaco,dt)
 use numerics, only: &
   subStepMinHomog, &
   subStepSizeHomog, &
   stepIncreaseHomog, &
   nMPstate
 use FEsolving, only: &
   FEsolving_execElem, &
   FEsolving_execIP, &
   terminallyIll
 use mesh, only: &
   mesh_element
 use material, only: &
   plasticState, &
   sourceState, &
   homogState, &
   thermalState, &
   damageState, &
   phase_Nsources, &
   material_homogenizationAt, &
   mappingHomogenization, &
   phaseAt, phasememberAt, &
   homogenization_Ngrains
 use crystallite, only: &
   crystallite_F0, &
   crystallite_Fp0, &
   crystallite_Fp, &
   crystallite_Fi0, &
   crystallite_Fi, &
   crystallite_Lp0, &
   crystallite_Lp, &
   crystallite_Li0, &
   crystallite_Li, &
   crystallite_S0, &
   crystallite_S, &
   crystallite_partionedF0, &
   crystallite_partionedF, &
   crystallite_partionedFp0, &
   crystallite_partionedLp0, &
   crystallite_partionedFi0, &
   crystallite_partionedLi0, &
   crystallite_partionedS0, &
   crystallite_dt, &
   crystallite_requested, &
   crystallite_stress, &
   crystallite_stressTangent, &
   crystallite_orientations
#ifdef DEBUG
 use debug, only: &
   debug_level, &
   debug_homogenization, &
   debug_levelBasic, &
   debug_levelExtensive, &
   debug_levelSelective, &
   debug_e, &
   debug_i
#endif

 implicit none
 real(pReal), intent(in) :: dt                                                                      !< time increment
 logical,     intent(in) :: updateJaco                                                              !< initiating Jacobian update
 integer(pInt) :: &
   NiterationHomog, &
   NiterationMPstate, &
   g, &                                                                                             !< grain number
   i, &                                                                                             !< integration point number
   e, &                                                                                             !< element number
   mySource, &
   myNgrains

#ifdef DEBUG
 if (iand(debug_level(debug_homogenization), debug_levelBasic) /= 0_pInt) then
     write(6,'(/a,i5,1x,i2)') '<< HOMOG >> Material Point start at el ip ', debug_e, debug_i

     write(6,'(a,/,3(12x,3(f14.9,1x)/))') '<< HOMOG >> F0', &
                                     transpose(materialpoint_F0(1:3,1:3,debug_i,debug_e))
     write(6,'(a,/,3(12x,3(f14.9,1x)/))') '<< HOMOG >> F', &
                                     transpose(materialpoint_F(1:3,1:3,debug_i,debug_e))
 endif
#endif

!--------------------------------------------------------------------------------------------------
! initialize restoration points of ...
 do e = FEsolving_execElem(1),FEsolving_execElem(2)
   myNgrains = homogenization_Ngrains(mesh_element(3,e))
   do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e); do g = 1,myNgrains

     plasticState    (phaseAt(g,i,e))%partionedState0(:,phasememberAt(g,i,e)) = &
     plasticState    (phaseAt(g,i,e))%state0(         :,phasememberAt(g,i,e))
     do mySource = 1_pInt, phase_Nsources(phaseAt(g,i,e))
       sourceState(phaseAt(g,i,e))%p(mySource)%partionedState0(:,phasememberAt(g,i,e)) = &
       sourceState(phaseAt(g,i,e))%p(mySource)%state0(         :,phasememberAt(g,i,e))
     enddo

     crystallite_partionedFp0(1:3,1:3,g,i,e) = crystallite_Fp0(1:3,1:3,g,i,e)                       ! ...plastic def grads
     crystallite_partionedLp0(1:3,1:3,g,i,e) = crystallite_Lp0(1:3,1:3,g,i,e)                       ! ...plastic velocity grads
     crystallite_partionedFi0(1:3,1:3,g,i,e) = crystallite_Fi0(1:3,1:3,g,i,e)                       ! ...intermediate def grads
     crystallite_partionedLi0(1:3,1:3,g,i,e) = crystallite_Li0(1:3,1:3,g,i,e)                       ! ...intermediate velocity grads
     crystallite_partionedF0(1:3,1:3,g,i,e)  = crystallite_F0(1:3,1:3,g,i,e)                        ! ...def grads
     crystallite_partionedS0(1:3,1:3,g,i,e)  = crystallite_S0(1:3,1:3,g,i,e)                        ! ...2nd PK stress

   enddo; enddo
   forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e))
     materialpoint_subF0(1:3,1:3,i,e) = materialpoint_F0(1:3,1:3,i,e)                               ! ...def grad
     materialpoint_subFrac(i,e) = 0.0_pReal
     materialpoint_subStep(i,e) = 1.0_pReal/subStepSizeHomog                                        ! <<added to adopt flexibility in cutback size>>
     materialpoint_converged(i,e) = .false.                                                         ! pretend failed step of twice the required size
     materialpoint_requested(i,e) = .true.                                                          ! everybody requires calculation
   endforall
   forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
     homogState(material_homogenizationAt(e))%sizeState > 0_pInt) &
       homogState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
       homogState(material_homogenizationAt(e))%State0(   :,mappingHomogenization(1,i,e))           ! ...internal homogenization state
   forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
     thermalState(material_homogenizationAt(e))%sizeState > 0_pInt) &
       thermalState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
       thermalState(material_homogenizationAt(e))%State0(   :,mappingHomogenization(1,i,e))         ! ...internal thermal state
   forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
     damageState(material_homogenizationAt(e))%sizeState > 0_pInt) &
       damageState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
       damageState(material_homogenizationAt(e))%State0(   :,mappingHomogenization(1,i,e))          ! ...internal damage state
 enddo
 NiterationHomog = 0_pInt

 cutBackLooping: do while (.not. terminallyIll .and. &
      any(materialpoint_subStep(:,FEsolving_execELem(1):FEsolving_execElem(2)) > subStepMinHomog))

   !$OMP PARALLEL DO PRIVATE(myNgrains)
   elementLooping1: do e = FEsolving_execElem(1),FEsolving_execElem(2)
     myNgrains = homogenization_Ngrains(mesh_element(3,e))
     IpLooping1: do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e)

       converged: if ( materialpoint_converged(i,e) ) then
#ifdef DEBUG
         if (iand(debug_level(debug_homogenization), debug_levelExtensive) /= 0_pInt &
            .and. ((e == debug_e .and. i == debug_i) &
                   .or. .not. iand(debug_level(debug_homogenization),debug_levelSelective) /= 0_pInt)) then
           write(6,'(a,1x,f12.8,1x,a,1x,f12.8,1x,a,i8,1x,i2/)') '<< HOMOG >> winding forward from', &
             materialpoint_subFrac(i,e), 'to current materialpoint_subFrac', &
             materialpoint_subFrac(i,e)+materialpoint_subStep(i,e),'in materialpoint_stressAndItsTangent at el ip',e,i
         endif
#endif

!---------------------------------------------------------------------------------------------------
! calculate new subStep and new subFrac
         materialpoint_subFrac(i,e) = materialpoint_subFrac(i,e) + materialpoint_subStep(i,e)
         materialpoint_subStep(i,e) = min(1.0_pReal-materialpoint_subFrac(i,e), &
                                          stepIncreaseHomog*materialpoint_subStep(i,e))             ! introduce flexibility for step increase/acceleration

         steppingNeeded: if (materialpoint_subStep(i,e) > subStepMinHomog) then

           ! wind forward grain starting point of...
           crystallite_partionedF0(1:3,1:3,1:myNgrains,i,e) =  &
              crystallite_partionedF(1:3,1:3,1:myNgrains,i,e)                                       ! ...def grads

           crystallite_partionedFp0(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_Fp(1:3,1:3,1:myNgrains,i,e)                                                ! ...plastic def grads

           crystallite_partionedLp0(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_Lp(1:3,1:3,1:myNgrains,i,e)                                                ! ...plastic velocity grads

           crystallite_partionedFi0(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_Fi(1:3,1:3,1:myNgrains,i,e)                                                ! ...intermediate def grads

           crystallite_partionedLi0(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_Li(1:3,1:3,1:myNgrains,i,e)                                                ! ...intermediate velocity grads

           crystallite_partionedS0(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_S(1:3,1:3,1:myNgrains,i,e)                                                 ! ...2nd PK stress

           do g = 1,myNgrains
             plasticState    (phaseAt(g,i,e))%partionedState0(:,phasememberAt(g,i,e)) = &
             plasticState    (phaseAt(g,i,e))%state(          :,phasememberAt(g,i,e))
             do mySource = 1_pInt, phase_Nsources(phaseAt(g,i,e))
               sourceState(phaseAt(g,i,e))%p(mySource)%partionedState0(:,phasememberAt(g,i,e)) = &
               sourceState(phaseAt(g,i,e))%p(mySource)%state(          :,phasememberAt(g,i,e))
             enddo
           enddo

           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             homogState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               homogState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
               homogState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e))   ! ...internal homogenization state
           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             thermalState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               thermalState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
               thermalState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e)) ! ...internal thermal state
           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             damageState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               damageState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) = &
               damageState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e))  ! ...internal damage state
           materialpoint_subF0(1:3,1:3,i,e) = materialpoint_subF(1:3,1:3,i,e)                       ! ...def grad
         endif steppingNeeded

       else converged
         if ( (myNgrains == 1_pInt .and. materialpoint_subStep(i,e) <= 1.0 ) .or. &                 ! single grain already tried internal subStepping in crystallite
              subStepSizeHomog * materialpoint_subStep(i,e) <=  subStepMinHomog ) then              ! would require too small subStep
                                                                                                    ! cutback makes no sense
           !$OMP FLUSH(terminallyIll)
           if (.not. terminallyIll) then                                                            ! so first signals terminally ill...
             !$OMP CRITICAL (write2out)
               write(6,*) 'Integration point ', i,' at element ', e, ' terminally ill'
             !$OMP END CRITICAL (write2out)
           endif
           !$OMP CRITICAL (setTerminallyIll)
             terminallyIll = .true.                                                                 ! ...and kills all others
           !$OMP END CRITICAL (setTerminallyIll)
         else                                                                                       ! cutback makes sense
           materialpoint_subStep(i,e) = subStepSizeHomog * materialpoint_subStep(i,e)               ! crystallite had severe trouble, so do a significant cutback

#ifdef DEBUG
           if (iand(debug_level(debug_homogenization), debug_levelExtensive) /= 0_pInt &
              .and. ((e == debug_e .and. i == debug_i) &
                    .or. .not. iand(debug_level(debug_homogenization), debug_levelSelective) /= 0_pInt)) then
             write(6,'(a,1x,f12.8,a,i8,1x,i2/)') &
               '<< HOMOG >> cutback step in materialpoint_stressAndItsTangent with new materialpoint_subStep:',&
               materialpoint_subStep(i,e),' at el ip',e,i
           endif
#endif

!--------------------------------------------------------------------------------------------------
! restore...
           crystallite_Fp(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_partionedFp0(1:3,1:3,1:myNgrains,i,e)                                      ! ...plastic def grads
           crystallite_Lp(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_partionedLp0(1:3,1:3,1:myNgrains,i,e)                                      ! ...plastic velocity grads
           crystallite_Fi(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_partionedFi0(1:3,1:3,1:myNgrains,i,e)                                      ! ...intermediate def grads
           crystallite_Li(1:3,1:3,1:myNgrains,i,e) = &
             crystallite_partionedLi0(1:3,1:3,1:myNgrains,i,e)                                      ! ...intermediate velocity grads
           crystallite_S(1:3,1:3,1:myNgrains,i,e) = &
              crystallite_partionedS0(1:3,1:3,1:myNgrains,i,e)                                      ! ...2nd PK stress
           do g = 1, myNgrains
             plasticState    (phaseAt(g,i,e))%state(          :,phasememberAt(g,i,e)) = &
             plasticState    (phaseAt(g,i,e))%partionedState0(:,phasememberAt(g,i,e))
             do mySource = 1_pInt, phase_Nsources(phaseAt(g,i,e))
               sourceState(phaseAt(g,i,e))%p(mySource)%state(          :,phasememberAt(g,i,e)) = &
               sourceState(phaseAt(g,i,e))%p(mySource)%partionedState0(:,phasememberAt(g,i,e))
             enddo
           enddo
           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             homogState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               homogState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e)) = &
               homogState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e))   ! ...internal homogenization state
           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             thermalState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               thermalState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e)) = &
               thermalState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e)) ! ...internal thermal state
           forall(i = FEsolving_execIP(1,e):FEsolving_execIP(2,e), &
             damageState(material_homogenizationAt(e))%sizeState > 0_pInt) &
               damageState(material_homogenizationAt(e))%State(    :,mappingHomogenization(1,i,e)) = &
               damageState(material_homogenizationAt(e))%subState0(:,mappingHomogenization(1,i,e))  ! ...internal damage state
         endif
       endif converged

       if (materialpoint_subStep(i,e) > subStepMinHomog) then
         materialpoint_requested(i,e) = .true.
         materialpoint_subF(1:3,1:3,i,e) = materialpoint_subF0(1:3,1:3,i,e) &
                                         + materialpoint_subStep(i,e) * (materialpoint_F(1:3,1:3,i,e) &
                                         - materialpoint_F0(1:3,1:3,i,e))
         materialpoint_subdt(i,e) = materialpoint_subStep(i,e) * dt
         materialpoint_doneAndHappy(1:2,i,e) = [.false.,.true.]
       endif
     enddo IpLooping1
   enddo elementLooping1
   !$OMP END PARALLEL DO

   NiterationMPstate = 0_pInt

   convergenceLooping: do while (.not. terminallyIll .and. &
             any(            materialpoint_requested(:,FEsolving_execELem(1):FEsolving_execElem(2)) &
                 .and. .not. materialpoint_doneAndHappy(1,:,FEsolving_execELem(1):FEsolving_execElem(2)) &
                ) .and. &
             NiterationMPstate < nMPstate)
     NiterationMPstate = NiterationMPstate + 1

!--------------------------------------------------------------------------------------------------
! deformation partitioning
! based on materialpoint_subF0,.._subF,crystallite_partionedF0, and homogenization_state,
! results in crystallite_partionedF
     !$OMP PARALLEL DO PRIVATE(myNgrains)
     elementLooping2: do e = FEsolving_execElem(1),FEsolving_execElem(2)
       myNgrains = homogenization_Ngrains(mesh_element(3,e))
       IpLooping2: do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e)
         if (      materialpoint_requested(i,e) .and. &                                             ! process requested but...
             .not. materialpoint_doneAndHappy(1,i,e)) then                                          ! ...not yet done material points
           call partitionDeformation(i,e)                                                           ! partition deformation onto constituents
           crystallite_dt(1:myNgrains,i,e) = materialpoint_subdt(i,e)                               ! propagate materialpoint dt to grains
           crystallite_requested(1:myNgrains,i,e) = .true.                                          ! request calculation for constituents
         else
           crystallite_requested(1:myNgrains,i,e) = .false.                                         ! calculation for constituents not required anymore
         endif
       enddo IpLooping2
     enddo elementLooping2
     !$OMP END PARALLEL DO

!--------------------------------------------------------------------------------------------------
! crystallite integration
! based on crystallite_partionedF0,.._partionedF
! incrementing by crystallite_dt
    
    materialpoint_converged = crystallite_stress() !ToDo: MD not sure if that is the best logic

!--------------------------------------------------------------------------------------------------
! state update
     !$OMP PARALLEL DO
     elementLooping3: do e = FEsolving_execElem(1),FEsolving_execElem(2)
       IpLooping3: do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e)
         if (      materialpoint_requested(i,e) .and. &
             .not. materialpoint_doneAndHappy(1,i,e)) then
           if (.not. materialpoint_converged(i,e)) then
             materialpoint_doneAndHappy(1:2,i,e) = [.true.,.false.]
           else
             materialpoint_doneAndHappy(1:2,i,e) = updateState(i,e)
             materialpoint_converged(i,e) = all(materialpoint_doneAndHappy(1:2,i,e))                  ! converged if done and happy
           endif
         endif
       enddo IpLooping3
     enddo elementLooping3
     !$OMP END PARALLEL DO

   enddo convergenceLooping

   NiterationHomog = NiterationHomog + 1_pInt

 enddo cutBackLooping
 
 if(updateJaco) call crystallite_stressTangent

 if (.not. terminallyIll ) then
   call crystallite_orientations()                                                                  ! calculate crystal orientations
   !$OMP PARALLEL DO
   elementLooping4: do e = FEsolving_execElem(1),FEsolving_execElem(2)
     IpLooping4: do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e)
       call averageStressAndItsTangent(i,e)
     enddo IpLooping4
   enddo elementLooping4
   !$OMP END PARALLEL DO
 else
   write(6,'(/,a,/)') '<< HOMOG >> Material Point terminally ill'
 endif

end subroutine materialpoint_stressAndItsTangent


!--------------------------------------------------------------------------------------------------
!> @brief parallelized calculation of result array at material points
!--------------------------------------------------------------------------------------------------
subroutine materialpoint_postResults
 use FEsolving, only: &
   FEsolving_execElem, &
   FEsolving_execIP
 use mesh, only: &
   mesh_element
 use material, only: &
   material_homogenizationAt, &
   homogState, &
   thermalState, &
   damageState, &
   plasticState, &
   sourceState, &
   material_phase, &
   homogenization_Ngrains, &
   microstructure_crystallite
 use crystallite, only: &
   crystallite_sizePostResults, &
   crystallite_postResults

 implicit none
 integer(pInt) :: &
   thePos, &
   theSize, &
   myNgrains, &
   myCrystallite, &
   g, &                                                                                             !< grain number
   i, &                                                                                             !< integration point number
   e                                                                                                !< element number

 !$OMP PARALLEL DO PRIVATE(myNgrains,myCrystallite,thePos,theSize)
   elementLooping: do e = FEsolving_execElem(1),FEsolving_execElem(2)
     myNgrains = homogenization_Ngrains(mesh_element(3,e))
     myCrystallite = microstructure_crystallite(mesh_element(4,e))
     IpLooping: do i = FEsolving_execIP(1,e),FEsolving_execIP(2,e)
       thePos = 0_pInt

       theSize = homogState       (material_homogenizationAt(e))%sizePostResults &
               + thermalState     (material_homogenizationAt(e))%sizePostResults &
               + damageState      (material_homogenizationAt(e))%sizePostResults
       materialpoint_results(thePos+1,i,e) = real(theSize,pReal)                                    ! tell size of homogenization results
       thePos = thePos + 1_pInt

       if (theSize > 0_pInt) then                                                                   ! any homogenization results to mention?
         materialpoint_results(thePos+1:thePos+theSize,i,e) = postResults(i,e)       ! tell homogenization results
         thePos = thePos + theSize
       endif

       materialpoint_results(thePos+1,i,e) = real(myNgrains,pReal)                                  ! tell number of grains at materialpoint
       thePos = thePos + 1_pInt

       grainLooping :do g = 1,myNgrains
         theSize = 1 + crystallite_sizePostResults(myCrystallite) + &
                   1 + plasticState    (material_phase(g,i,e))%sizePostResults + &                    !ToDo
                       sum(sourceState(material_phase(g,i,e))%p(:)%sizePostResults)
         materialpoint_results(thePos+1:thePos+theSize,i,e) = crystallite_postResults(g,i,e)        ! tell crystallite results
         thePos = thePos + theSize
       enddo grainLooping
     enddo IpLooping
   enddo elementLooping
 !$OMP END PARALLEL DO

end subroutine materialpoint_postResults


!--------------------------------------------------------------------------------------------------
!> @brief  partition material point def grad onto constituents
!--------------------------------------------------------------------------------------------------
subroutine partitionDeformation(ip,el)
 use mesh, only: &
   mesh_element
 use material, only: &
   homogenization_type, &
   homogenization_Ngrains, &
   HOMOGENIZATION_NONE_ID, &
   HOMOGENIZATION_ISOSTRAIN_ID, &
   HOMOGENIZATION_RGC_ID
 use crystallite, only: &
   crystallite_partionedF
 use homogenization_isostrain, only: &
   homogenization_isostrain_partitionDeformation
 use homogenization_RGC, only: &
   homogenization_RGC_partitionDeformation

 implicit none
 integer(pInt), intent(in) :: &
   ip, &                                                                                            !< integration point
   el                                                                                               !< element number

 chosenHomogenization: select case(homogenization_type(mesh_element(3,el)))

   case (HOMOGENIZATION_NONE_ID) chosenHomogenization
     crystallite_partionedF(1:3,1:3,1,ip,el) = materialpoint_subF(1:3,1:3,ip,el)

   case (HOMOGENIZATION_ISOSTRAIN_ID) chosenHomogenization
     call homogenization_isostrain_partitionDeformation(&
                          crystallite_partionedF(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
                          materialpoint_subF(1:3,1:3,ip,el))

   case (HOMOGENIZATION_RGC_ID) chosenHomogenization
     call homogenization_RGC_partitionDeformation(&
                         crystallite_partionedF(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
                         materialpoint_subF(1:3,1:3,ip,el),&
                         ip, &
                         el)
 end select chosenHomogenization

end subroutine partitionDeformation


!--------------------------------------------------------------------------------------------------
!> @brief update the internal state of the homogenization scheme and tell whether "done" and
!> "happy" with result
!--------------------------------------------------------------------------------------------------
function updateState(ip,el)
 use mesh, only: &
   mesh_element
 use material, only: &
   homogenization_type, &
   thermal_type, &
   damage_type, &
   homogenization_Ngrains, &
   HOMOGENIZATION_RGC_ID, &
   THERMAL_adiabatic_ID, &
   DAMAGE_local_ID
 use crystallite, only: &
   crystallite_P, &
   crystallite_dPdF, &
   crystallite_partionedF,&
   crystallite_partionedF0
 use homogenization_RGC, only: &
   homogenization_RGC_updateState
 use thermal_adiabatic, only: &
   thermal_adiabatic_updateState
 use damage_local, only: &
   damage_local_updateState

 implicit none
 integer(pInt), intent(in) :: &
   ip, &                                                                                            !< integration point
   el                                                                                               !< element number
 logical, dimension(2) :: updateState

 updateState = .true.
 chosenHomogenization: select case(homogenization_type(mesh_element(3,el)))
   case (HOMOGENIZATION_RGC_ID) chosenHomogenization
     updateState = &
       updateState .and. &
        homogenization_RGC_updateState(crystallite_P(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
                                       crystallite_partionedF(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
                                       crystallite_partionedF0(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el),&
                                       materialpoint_subF(1:3,1:3,ip,el),&
                                       materialpoint_subdt(ip,el), &
                                       crystallite_dPdF(1:3,1:3,1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
                                       ip, &
                                       el)
 end select chosenHomogenization

 chosenThermal: select case (thermal_type(mesh_element(3,el)))
   case (THERMAL_adiabatic_ID) chosenThermal
     updateState = &
       updateState .and. &
       thermal_adiabatic_updateState(materialpoint_subdt(ip,el), &
                                     ip, &
                                     el)
 end select chosenThermal

 chosenDamage: select case (damage_type(mesh_element(3,el)))
   case (DAMAGE_local_ID) chosenDamage
     updateState = &
       updateState .and. &
       damage_local_updateState(materialpoint_subdt(ip,el), &
                                ip, &
                                el)
 end select chosenDamage

end function updateState


!--------------------------------------------------------------------------------------------------
!> @brief derive average stress and stiffness from constituent quantities
!--------------------------------------------------------------------------------------------------
subroutine averageStressAndItsTangent(ip,el)
 use mesh, only: &
   mesh_element
 use material, only: &
   homogenization_type, &
   homogenization_typeInstance, &
   homogenization_Ngrains, &
   HOMOGENIZATION_NONE_ID, &
   HOMOGENIZATION_ISOSTRAIN_ID, &
   HOMOGENIZATION_RGC_ID
 use crystallite, only: &
   crystallite_P,crystallite_dPdF
 use homogenization_isostrain, only: &
   homogenization_isostrain_averageStressAndItsTangent
 use homogenization_RGC, only: &
   homogenization_RGC_averageStressAndItsTangent

 implicit none
 integer(pInt), intent(in) :: &
   ip, &                                                                                            !< integration point
   el                                                                                               !< element number

 chosenHomogenization: select case(homogenization_type(mesh_element(3,el)))
   case (HOMOGENIZATION_NONE_ID) chosenHomogenization
       materialpoint_P(1:3,1:3,ip,el)            = crystallite_P(1:3,1:3,1,ip,el)
       materialpoint_dPdF(1:3,1:3,1:3,1:3,ip,el) = crystallite_dPdF(1:3,1:3,1:3,1:3,1,ip,el)

   case (HOMOGENIZATION_ISOSTRAIN_ID) chosenHomogenization
     call homogenization_isostrain_averageStressAndItsTangent(&
       materialpoint_P(1:3,1:3,ip,el), &
       materialpoint_dPdF(1:3,1:3,1:3,1:3,ip,el),&
       crystallite_P(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
       crystallite_dPdF(1:3,1:3,1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
       homogenization_typeInstance(mesh_element(3,el)))

   case (HOMOGENIZATION_RGC_ID) chosenHomogenization
     call homogenization_RGC_averageStressAndItsTangent(&
       materialpoint_P(1:3,1:3,ip,el), &
       materialpoint_dPdF(1:3,1:3,1:3,1:3,ip,el),&
       crystallite_P(1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
       crystallite_dPdF(1:3,1:3,1:3,1:3,1:homogenization_Ngrains(mesh_element(3,el)),ip,el), &
       homogenization_typeInstance(mesh_element(3,el)))
 end select chosenHomogenization

end subroutine averageStressAndItsTangent


!--------------------------------------------------------------------------------------------------
!> @brief return array of homogenization results for post file inclusion. call only,
!> if homogenization_sizePostResults(i,e) > 0 !!
!--------------------------------------------------------------------------------------------------
function postResults(ip,el)
 use mesh, only: &
   mesh_element
 use material, only: &
   thermalMapping, &
   thermal_typeInstance, &
   material_homogenizationAt, &
   homogenization_typeInstance,&
   mappingHomogenization, &
   homogState, &
   thermalState, &
   damageState, &
   homogenization_type, &
   thermal_type, &
   damage_type, &
   HOMOGENIZATION_NONE_ID, &
   HOMOGENIZATION_ISOSTRAIN_ID, &
   HOMOGENIZATION_RGC_ID, &
   THERMAL_isothermal_ID, &
   THERMAL_adiabatic_ID, &
   THERMAL_conduction_ID, &
   DAMAGE_none_ID, &
   DAMAGE_local_ID, &
   DAMAGE_nonlocal_ID
 use homogenization_RGC, only: &
   homogenization_RGC_postResults
 use thermal_adiabatic, only: &
   thermal_adiabatic_postResults
 use thermal_conduction, only: &
   thermal_conduction_postResults
 use damage_local, only: &
   damage_local_postResults
 use damage_nonlocal, only: &
   damage_nonlocal_postResults

 implicit none
 integer(pInt), intent(in) :: &
   ip, &                                                                                            !< integration point
   el                                                                                               !< element number
 real(pReal), dimension(  homogState       (material_homogenizationAt(el))%sizePostResults &
                        + thermalState     (material_homogenizationAt(el))%sizePostResults &
                        + damageState      (material_homogenizationAt(el))%sizePostResults) :: &
   postResults
 integer(pInt) :: &
   startPos, endPos ,&
   of, instance, homog


 postResults = 0.0_pReal
 startPos = 1_pInt
 endPos   = homogState(material_homogenizationAt(el))%sizePostResults
 chosenHomogenization: select case (homogenization_type(mesh_element(3,el)))

   case (HOMOGENIZATION_RGC_ID) chosenHomogenization
     instance = homogenization_typeInstance(material_homogenizationAt(el))
     of = mappingHomogenization(1,ip,el)
     postResults(startPos:endPos) = homogenization_RGC_postResults(instance,of)
     
 end select chosenHomogenization

 startPos = endPos + 1_pInt
 endPos   = endPos + thermalState(material_homogenizationAt(el))%sizePostResults
 chosenThermal: select case (thermal_type(mesh_element(3,el)))

   case (THERMAL_adiabatic_ID) chosenThermal
     homog = material_homogenizationAt(el)
     postResults(startPos:endPos) = &
       thermal_adiabatic_postResults(homog,thermal_typeInstance(homog),thermalMapping(homog)%p(ip,el))
   case (THERMAL_conduction_ID) chosenThermal
     homog = material_homogenizationAt(el)
     postResults(startPos:endPos) = &
       thermal_conduction_postResults(homog,thermal_typeInstance(homog),thermalMapping(homog)%p(ip,el))

 end select chosenThermal

 startPos = endPos + 1_pInt
 endPos   = endPos + damageState(material_homogenizationAt(el))%sizePostResults
 chosenDamage: select case (damage_type(mesh_element(3,el)))

   case (DAMAGE_local_ID) chosenDamage
     postResults(startPos:endPos) = damage_local_postResults(ip, el)
   case (DAMAGE_nonlocal_ID) chosenDamage
     postResults(startPos:endPos) = damage_nonlocal_postResults(ip, el)
     
 end select chosenDamage

end function postResults

end module homogenization
